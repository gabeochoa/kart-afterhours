<!doctype html>
<html lang="en">
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>System Subscriptions</title>
<style>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 0px;
  }
  
  body {
    font-family: sans-serif;
    margin: 0;
    padding: 0px 0;
    background: #f5f5f5;
  }
  
  .layout {
    display: grid;
    grid-template-rows: auto 1fr;
    gap: 16px;
    min-height: calc(100vh - 32px);
  }
  
  .main {
    display: grid;
    grid-template-columns: 280px 1fr 300px;
    gap: 16px;
    align-items: stretch;
    min-height: 0;
  }
  
  .panel:first-child {
    overflow: hidden;
  }
  
  .panel {
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .panel h2 {
    margin: 0;
    padding: 12px 16px;
    border-bottom: 1px solid #eee;
    font-size: 16px;
    font-weight: 600;
    color: #333;
  }
  
  .panel .content {
    padding: 16px;
  }
  
  .sections {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    gap: 12px;
    height: 100%;
  }
  
  .section {
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  
  .list {
    flex: 1;
    overflow: auto;
    max-height: 120px;
  }
  
  .system {
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
    border: 1px solid transparent;
  }
  
  .system:hover {
    background: #f0f8ff;
    border-color: #e0e0e0;
  }
  
  .system.active {
    background: #e3f2fd;
    border-color: #2196f3;
  }
  
  .count {
    font-size: 11px;
    margin-left: 6px;
    opacity: 0.8;
  }
  
  .count.read {
    color: #000;
  }
  
  .count.write {
    color: #d32f2f;
  }
  
  .badge {
    display: inline-block;
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 12px;
    background: #e8f5e8;
    color: #2e7d32;
    font-weight: 500;
    margin-bottom: 8px;
  }
  
  .controls {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
  }
  
  .controls input {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
  }
  
  .controls input:focus {
    outline: none;
    border-color: #2196f3;
    box-shadow: 0 0 0 2px rgba(33,150,243,0.2);
  }
  
  .graph-wrap {
    height: 100%;
    min-height: 400px;
  }
  
  .graph {
    width: 100%;
    height: 100%;
    border: 1px solid #eee;
    border-radius: 6px;
    background: #fff;
    min-height: 100%;
    display: block;
  }
  
  .graph svg {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  /* Components bar */
  .compbar {
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #fff;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .compbar .row {
    display: flex;
    gap: 8px;
    overflow: auto;
    white-space: nowrap;
    padding: 4px 0;
  }
  
  .chip {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 16px;
    background: #f0f0f0;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid #e0e0e0;
    font-size: 13px;
  }
  
  .chip:hover {
    background: #e0e0e0;
    transform: translateY(-1px);
  }
  
  .legend {
    font-size: 13px;
    color: #666;
    font-style: italic;
  }
  
  .result-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }
  
  .col {
    border: 1px dashed #ddd;
    border-radius: 6px;
    padding: 12px;
    min-height: 100px;
    background: #fafafa;
  }
  
  .col h3 {
    margin: 0 0 8px 0;
    font-size: 14px;
    color: #333;
    font-weight: 600;
  }
  
  .entry {
    padding: 6px 8px;
    margin: 3px 0;
    border-radius: 4px;
    background: #fff;
    display: flex;
    align-items: center;
    gap: 6px;
    border: 1px solid #f0f0f0;
  }
  
  .arrow {
    font-weight: bold;
  }
  
  .arrow.red {
    color: #d32f2f;
  }
  
  .arrow.black {
    color: #000;
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .main {
      grid-template-columns: 1fr;
      gap: 12px;
    }
    
    .sections {
      max-height: 300px;
    }
    
    .list {
      max-height: 80px;
    }
    
    .result-grid {
      grid-template-columns: 1fr;
    }
  }
  
  @media (max-width: 1200px) {
    .main {
      grid-template-columns: 280px 1fr;
    }
    
    .panel:last-child {
      grid-column: 1 / -1;
      margin-top: 16px;
    }
  }
</style>
<div class="container">
<div class="layout">
  <div class="main">
    <div class="panel">
      <h2>Systems</h2>
      <div class="content">
        <div class="controls">
          <input id="search-sys" type="text" placeholder="Filter systems" />
        </div>
        <div class="sections">
          <div class="section">
            <div class="badge">fixed_update</div>
            <div id="systems-fixed_update" class="list"></div>
          </div>
          <div class="section">
            <div class="badge">update</div>
            <div id="systems-update" class="list"></div>
          </div>
          <div class="section">
            <div class="badge">render</div>
            <div id="systems-render" class="list"></div>
          </div>
          <div class="section">
            <div class="badge">unknown</div>
            <div id="systems-unknown" class="list"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2 id="detail-title">Details</h2>
      <div class="content">
        <div class="graph-wrap">
          <svg id="graph" class="graph"></svg>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2>Components</h2>
      <div class="content">
        <div class="legend">Click a component to see its systems in the details panel</div>
        <div id="comp-row" class="row"></div>
      </div>
    </div>
  </div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script>
const summary = [[SUMMARY_JSON]];
const systems = summary.systems.map(s => ({
  name: s.name, stage: s.stage, order: s.order,
  declared: s.declared_components,
  reads: new Set(s.reads), writes: new Set(s.writes)
}));
const byStage = systems.reduce((a,s)=>{(a[s.stage] ||= []).push(s);return a;},{});
for(const st of Object.keys(byStage)) byStage[st].sort((a,b)=>a.order-b.order);
const containers = { 'fixed_update':document.getElementById('systems-fixed_update'), 'update':document.getElementById('systems-update'), 'render':document.getElementById('systems-render'), 'unknown':document.getElementById('systems-unknown') };
const detailTitle = document.getElementById('detail-title');
const svg = d3.select('#graph'); 
const g = svg.append('g'); 
const defs = svg.append('defs');

defs.append('marker')
  .attr('id','arrow-black')
  .attr('viewBox','0 0 10 10')
  .attr('refX',10)
  .attr('refY',5)
  .attr('markerWidth',6)
  .attr('markerHeight',6)
  .attr('orient','auto-start-reverse')
  .append('path')
  .attr('d','M 0 0 L 10 5 L 0 10 z')
  .attr('fill','#000');

defs.append('marker')
  .attr('id','arrow-red')
  .attr('viewBox','0 0 10 10')
  .attr('refX',10)
  .attr('refY',5)
  .attr('markerWidth',6)
  .attr('markerHeight',6)
  .attr('orient','auto-start-reverse')
  .append('path')
  .attr('d','M 0 0 L 10 5 L 0 10 z')
  .attr('fill','#c00');

// Reusable node creation functions
function makeSystemNode(g, x, y, name, color = '#000') {
  const node = g.append('g').attr('class', 'system-node');
  node.append('rect')
    .attr('x', -40).attr('y', -25)
    .attr('width', 80).attr('height', 50)
    .attr('rx', 6).attr('ry', 6)
    .attr('fill', '#f5f5f5')
    .attr('stroke', color)
    .attr('stroke-width', 2);
  
  const text = node.append('text')
    .attr('x', 0).attr('y', 0)
    .attr('text-anchor', 'middle')
    .attr('dominant-baseline', 'middle')
    .attr('font-size', 12)
    .text(name);
  
  // Fit text to node
  let fontSize = 12;
  while (text.node().getComputedTextLength() > 70 && fontSize > 8) {
    fontSize--;
    text.attr('font-size', fontSize);
  }
  
  return node;
}

function makeComponentNode(g, x, y, name, color = '#000') {
  const node = g.append('g').attr('class', 'component-node');
  node.append('circle')
    .attr('cx', 0).attr('cy', 0).attr('r', 20)
    .attr('fill', '#f7f7f7')
    .attr('stroke', color)
    .attr('stroke-width', 2);
  
  const text = node.append('text')
    .attr('x', 0).attr('y', 0)
    .attr('text-anchor', 'middle')
    .attr('dominant-baseline', 'middle')
    .attr('font-size', 12)
    .text(name);
  
  // Fit text to node
  let fontSize = 12;
  while (text.node().getComputedTextLength() > 35 && fontSize > 8) {
    fontSize--;
    text.attr('font-size', fontSize);
  }
  
  return node;
}

function renderSystemList(filter = '') {
  const stages = ['fixed_update', 'update', 'render', 'unknown'];
  const filtered = systems.filter(s => s.name.toLowerCase().includes(filter));
  
  for (const stage of stages) {
    const parent = containers[stage];
    if (!parent) continue;
    
    parent.innerHTML = '';
    
    filtered
      .filter(s => s.stage === stage)
      .sort((a, b) => a.order - b.order)
      .forEach(s => {
        const div = document.createElement('div');
        div.className = 'system';
        div.dataset.name = s.name;
        
        const prefix = s.order >= 0 ? String(s.order).padStart(2, '0') + ': ' : '';
        const reads = s.reads.size || 0;
        const writes = s.writes.size || 0;
        
        div.innerHTML = `${prefix}${s.name} <span class="count read">(${reads})</span><span class="count write">(${writes})</span>`;
        div.addEventListener('click', () => selectSystem(s.name));
        
        parent.appendChild(div);
      });
  }
}

function selectSystem(name) {
  const s = systems.find(x => x.name === name);
  if (!s) return;
  
  detailTitle.textContent = `Details — ${s.name}`;
  drawSystemGraph(s);
  
  document.querySelectorAll('.system').forEach(el => 
    el.classList.toggle('active', el.dataset.name === name)
  );
}

// Build components row
const components = Array.from(new Set(systems.flatMap(s => [...s.reads, ...s.writes]))).sort();
const compRow = document.getElementById('comp-row');

components.forEach(c => {
  const chip = document.createElement('span');
  chip.className = 'chip';
  chip.textContent = c;
  chip.addEventListener('click', () => showComponentUsage(c));
  compRow.appendChild(chip);
});

function showComponentUsage(component) {
  const writers = systems.filter(s => s.writes.has(component))
    .sort((a, b) => a.stage === b.stage ? a.order - b.order : a.stage.localeCompare(b.stage));
  
  const readers = systems.filter(s => s.reads.has(component))
    .sort((a, b) => a.stage === b.stage ? a.order - b.order : a.stage.localeCompare(b.stage));
  
  // Update the middle panel to show component usage
  detailTitle.textContent = `Component — ${component}`;
  
  // Create a component-centric graph
  drawComponentGraph(component, writers, readers);
  
  // Clear any active system selection
  document.querySelectorAll('.system').forEach(el => el.classList.remove('active'));
}

function drawSystemGraph(s){
  const container = document.querySelector('.graph-wrap');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  svg.attr('width', width).attr('height', height).attr('viewBox',`0 0 ${width} ${height}`);
  g.selectAll('*').remove();
  const margin=80, sysW=180, sysH=70, centerX=width/2, centerY=height/2, leftX=margin+50, rightX=width-margin-50, bottomY=height-margin-100, vGap=60, hGap=220, nodeR=16;
  const all = new Set([...s.reads, ...s.writes]);
  const reads=[...all].filter(c=>s.reads.has(c) && !s.writes.has(c)).sort();
  const writes=[...all].filter(c=>s.writes.has(c) && !s.reads.has(c)).sort();
  const both=[...all].filter(c=>s.reads.has(c) && s.writes.has(c)).sort();
  const nodes=[]; nodes.push({id:s.name,type:'system',x:centerX,y:centerY,tx:centerX,ty:centerY});
  const leftStartY=centerY-((reads.length-1)*vGap)/2; reads.forEach((c,i)=>nodes.push({id:c,type:'read',x:leftX,y:leftStartY+i*vGap,tx:leftX,ty:leftStartY+i*vGap}));
  const rightStartY=centerY-((writes.length-1)*vGap)/2; writes.forEach((c,i)=>nodes.push({id:c,type:'write',x:rightX,y:rightStartY+i*vGap,tx:rightX,ty:rightStartY+i*vGap}));
  const bottomStartX=centerX-((both.length-1)*hGap)/2; both.forEach((c,i)=>nodes.push({id:c,type:'both',x:bottomStartX+i*hGap,y:bottomY,tx:bottomStartX+i*hGap,ty:bottomY}));
  const nodeById=new Map(nodes.map(n=>[n.id,n]));
  g.append('rect').attr('x',centerX-sysW/2).attr('y',centerY-sysH/2).attr('width',sysW).attr('height',sysH).attr('rx',8).attr('ry',8).attr('fill','#eee').attr('stroke','#999');
  g.append('text').attr('x',centerX).attr('y',centerY).attr('text-anchor','middle').attr('dominant-baseline','middle').attr('font-size',14).text(s.name);
  const links=[]; reads.forEach(c=>links.push({from:c,to:s.name,color:'#000',dir:'in'})); writes.forEach(c=>links.push({from:s.name,to:c,color:'#c00',dir:'out'})); both.forEach(c=>{links.push({from:c,to:s.name,color:'#000',dir:'in'});links.push({from:s.name,to:c,color:'#c00',dir:'out'});});
  const linkSel=g.selectAll('path.link').data(links).enter().append('path').attr('class','link').attr('fill','none').attr('stroke',d=>d.color).attr('stroke-width',2).attr('stroke-linecap','round').attr('marker-end',d=>d.color==='#c00'?'url(#arrow-red)':'url(#arrow-black)');
  const compNodes = nodes.filter(n => n.type !== 'system'); 
  const nodeSel = g.selectAll('g.node').data(compNodes, d => d.id).enter().append('g').attr('class', 'node');
  
  // Create component nodes using the reusable function
  nodeSel.each(function(d) {
    const color = d.type === 'write' ? '#c00' : (d.type === 'read' ? '#000' : '#555');
    makeComponentNode(d3.select(this), d.x, d.y, d.id, color);
  });
  function edgePoints(l){ const a=nodeById.get(l.from), b=nodeById.get(l.to); if(!a||!b) return null; let x1=a.x,y1=a.y,x2=b.x,y2=b.y; if(l.dir==='in'){x2=centerX-sysW/2;y2=centerY;} if(l.dir==='out'){x1=centerX+sysW/2;y1=centerY;} return {x1,y1,x2,y2}; }
  function updateLinks(){ linkSel.attr('d', d=>{ const p=edgePoints(d); if(!p) return ''; const dx=p.x2-p.x1, dy=p.y2-p.y1, midx=p.x1+dx*0.5; let curv=Math.min(80.0, Math.abs(dx)/3.0); if(d.color==='#000') curv=-curv; const c1y=p.y1+dy*0.25+curv; const c2y=p.y2-dy*0.25+curv; return `M ${p.x1} ${p.y1} C ${midx} ${c1y}, ${midx} ${c2y}, ${p.x2} ${p.y2}`; }); }
  function updateNodes(){ nodeSel.attr('transform', d=>`translate(${d.x},${d.y})`); nodeSel.selectAll('text').attr('y', d=> d.type==='both' ? (16+14) : (-16-10)).text(d=>d.id); }
  // Drag to reposition
  nodeSel.call(d3.drag()
    .on('start', (event,d)=>{ d.fx = d.x; d.fy = d.y; if (simulation) simulation.alphaTarget(0.2).restart(); })
    .on('drag', (event,d)=>{ d.fx = event.x; d.fy = event.y; })
    .on('end', (event,d)=>{ d.fx = null; d.fy = null; if (simulation) simulation.alphaTarget(0); }));

  // Force simulation for floaty behavior
  const simulation = d3.forceSimulation(compNodes)
    .force('x', d3.forceX(d=>d.tx).strength(0.08))
    .force('y', d3.forceY(d=>d.ty).strength(0.08))
    .force('charge', d3.forceManyBody().strength(-180))
    .force('collide', d3.forceCollide().radius(26).iterations(2))
    .alpha(1)
    .alphaDecay(0.08)
    .on('tick', ()=>{ updateNodes(); updateLinks(); });

  updateNodes(); updateLinks();
}

function drawComponentGraph(component, writers, readers){
  const container = document.querySelector('.graph-wrap');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  svg.attr('width', width).attr('height', height).attr('viewBox',`0 0 ${width} ${height}`);
  g.selectAll('*').remove();
  const margin=80, compW=200, compH=80, centerX=width/2, centerY=height/2, leftX=margin+50, rightX=width-margin-50, vGap=80, nodeR=20;
  
  const nodes=[]; 
  nodes.push({id:component,type:'component',x:centerX,y:centerY,tx:centerX,ty:centerY});
  
  const leftStartY=centerY-((writers.length-1)*vGap)/2; 
  writers.forEach((s,i)=>nodes.push({id:s.name,type:'writer',x:leftX,y:leftStartY+i*vGap,tx:leftX,ty:leftStartY+i*vGap}));
  
  const rightStartY=centerY-((readers.length-1)*vGap)/2; 
  readers.forEach((s,i)=>nodes.push({id:s.name,type:'reader',x:rightX,y:rightStartY+i*vGap,tx:rightX,ty:rightStartY+i*vGap}));
  
  const nodeById=new Map(nodes.map(n=>[n.id,n]));
  
  // Draw component in center
  g.append('circle').attr('cx',centerX).attr('cy',centerY).attr('r',40).attr('fill','#e8f5e8').attr('stroke','#4caf50').attr('stroke-width',2);
  g.append('text').attr('x',centerX).attr('y',centerY).attr('text-anchor','middle').attr('dominant-baseline','middle').attr('font-size',16).attr('font-weight','bold').text(component);
  
  // Create links
  const links=[];
  writers.forEach(s=>links.push({from:s.name,to:component,color:'#d32f2f',dir:'to'}));
  readers.forEach(s=>links.push({from:component,to:s.name,color:'#000',dir:'from'}));
  
  const linkSel=g.selectAll('path.link').data(links).enter().append('path').attr('class','link').attr('fill','none').attr('stroke',d=>d.color).attr('stroke-width',3).attr('stroke-linecap','round').attr('marker-end',d=>d.color==='#d32f2f'?'url(#arrow-red)':'url(#arrow-black)');
  
  const sysNodes=nodes.filter(n=>n.type!=='component'); 
  const nodeSel=g.selectAll('g.node').data(sysNodes, d=>d.id).enter().append('g').attr('class','node');
  
  // Create system nodes using the reusable function
  nodeSel.each(function(d) {
    const color = d.type==='writer' ? '#d32f2f' : '#000';
    makeSystemNode(d3.select(this), d.x, d.y, d.id, color);
  });
  
  function edgePoints(l){ 
    const a=nodeById.get(l.from), b=nodeById.get(l.to); 
    if(!a||!b) return null; 
    let x1=a.x,y1=a.y,x2=b.x,y2=b.y; 
    if(l.dir==='to'){x2=centerX-40;y2=centerY;} 
    if(l.dir==='from'){x1=centerX+40;y1=centerY;} 
    return {x1,y1,x2,y2}; 
  }
  
  function updateLinks(){ 
    linkSel.attr('d', d=>{ 
      const p=edgePoints(d); 
      if(!p) return ''; 
      const dx=p.x2-p.x1, dy=p.y2-p.y1, midx=p.x1+dx*0.5; 
      let curv=Math.min(100.0, Math.abs(dx)/2.5); 
      if(d.color==='#000') curv=-curv; 
      const c1y=p.y1+dy*0.25+curv; 
      const c2y=p.y2-dy*0.25+curv; 
      return `M ${p.x1} ${p.y1} C ${midx} ${c1y}, ${midx} ${c2y}, ${p.x2} ${p.y2}`; 
    }); 
  }
  
  function updateNodes(){ 
    nodeSel.attr('transform', d=>`translate(${d.x},${d.y})`); 
  }
  
  // Drag to reposition
  nodeSel.call(d3.drag()
    .on('start', (event,d)=>{ d.fx = d.x; d.fy = d.y; if (simulation) simulation.alphaTarget(0.2).restart(); })
    .on('drag', (event,d)=>{ d.fx = event.x; d.fy = event.y; })
    .on('end', (event,d)=>{ d.fx = null; d.fy = null; if (simulation) simulation.alphaTarget(0); }));

  // Force simulation for floaty behavior
  const simulation = d3.forceSimulation(sysNodes)
    .force('x', d3.forceX(d=>d.tx).strength(0.1))
    .force('y', d3.forceY(d=>d.ty).strength(0.1))
    .force('charge', d3.forceManyBody().strength(-200))
    .force('collide', d3.forceCollide().radius(30).iterations(2))
    .alpha(1)
    .alphaDecay(0.1)
    .on('tick', ()=>{ updateNodes(); updateLinks(); });

  updateNodes(); updateLinks();
}

document.getElementById('search-sys').addEventListener('input', e=>{ renderSystemList(e.target.value.trim().toLowerCase()); });
renderSystemList(''); const first = systems.slice().sort((a,b)=> (a.stage.localeCompare(b.stage)) || (a.order-b.order))[0]; if(first) selectSystem(first.name);
</script>
</html>
